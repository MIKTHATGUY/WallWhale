# File hosting utility (src/utils/fileHosting.ts)

This document explains the temporary file hosting helper that uses `directDownload` to fetch Steam Workshop items and serves them over HTTP for short-term sharing.

## Purpose

- Download one or more Steam Workshop items to a temporary directory using a specified Steam account.
- Provide a simple HTTP(S) listing page with downloadable ZIP files and optional password protection.
- Auto-expire and clean up hosted files after a configurable time window.

## Public API

- `hostFiles(options: FileHostingOptions): Promise<FileHostingResult>`
  - `FileHostingOptions`:
    - `ids: string[]` — list of Workshop URLs or numeric IDs to host.
    - `accountName: string` — Steam account name stored in DB to use for authentication.
    - `port: number` — port to start server on.
    - `host: string` — host to bind (e.g. `0.0.0.0` or `localhost`).
    - `password?: string` — optional password to protect access via a simple query parameter check.
    - `expireHours: number` — number of hours before auto-cleanup (0 or negative => long-lived/‘never’ behavior).
    - `ssl: boolean` — whether the returned base URL should use https (server in this helper is HTTP; TLS must be provided externally).
    - `onProgress?: (message: string) => void` — optional progress callback used during downloads and setup.
  - Returns `FileHostingResult` containing the base URL, list of hosted files (with download URLs relative to that base), expiration time, and optional QR code data (not implemented in code).

## Core behavior & flow

1. Create a unique hosting session id and temporary download directory under the OS temp folder.
2. For each requested Workshop id, call `directDownload` with `createZip: true` and `cleanup: true` so the direct-download helper produces a ZIP file.
3. Collect successful ZIP files into a `HostingSession` with metadata (name, size, local path, download route).
4. Start a minimal HTTP server that:
   - Serves a friendly HTML listing at `/` (generated by `generateFileListingHTML`) that includes file names, sizes, Workshop IDs, and a countdown if the session expires.
   - Serves files at `/download/:id` by streaming the ZIP with appropriate headers (`Content-Type: application/zip` and `Content-Disposition`).
   - Implements password protection by checking `/?password=<value>` against the session password; when missing or incorrect the server responds with a small password entry page.
5. If `expireHours > 0` the helper schedules server shutdown and disk cleanup after the specified interval.

## HTML listing

- `generateFileListingHTML(session, baseUrl)` produces a responsive, clean UI with a header, status cards (file count, total MB, readiness, countdown), file cards with download buttons, and a footer.
- The page includes a JavaScript countdown when an expiration is set.
- Styling is self-contained in the returned HTML; no external assets required.

## Security & operational notes

- Password protection is minimal: it checks a query parameter `password`. This is convenient for quick sharing but not secure for production. For stronger protection, integrate proper auth (tokens, signed URLs, or reverse-proxy auth).
- The server serves raw ZIP files and does not perform additional sanitization. Ensure uploaded content comes from trusted sources and paths are not exposed outside the intended files.
- The helper uses OS temp directories; ensure adequate disk space and permissions for the expected workloads.
- TLS is not implemented inside this helper. To serve securely (HTTPS), either run behind a reverse proxy (nginx, Caddy) that terminates TLS or extend the helper to create an HTTPS server with certificates.
- Logs: the helper prints progress/log lines during downloads. Avoid printing secrets (passwords) and consider restricting console output in automated contexts.

## Error handling

- If no files succeed downloading, `hostFiles` throws `No files were successfully downloaded`.
- Individual download failures are caught and reported via `options.onProgress`, but do not halt the remaining downloads.
- If the server fails to start (port in use, permissions), the returned Promise rejects with the underlying error.

## Usage example (script)

```ts
import { hostFiles } from "../src/utils/fileHosting";

(async () => {
  const result = await hostFiles({
    ids: ["123456789", "987654321"],
    accountName: "default",
    port: 8081,
    host: "0.0.0.0",
    expireHours: 2,
    ssl: false,
    password: "temporary-pass",
    onProgress: (m) => console.log("progress:", m),
  });

  console.log(`Files hosted at: ${result.url}`);
  result.files.forEach((f) => console.log(` - ${f.name}: ${f.downloadUrl}`));
})();
```

## Edge cases & recommendations

- ID extraction and validation: upstream code should pass valid Workshop IDs or full URLs; the `directDownload` extractor is heuristic and may mis-detect digits in odd inputs.
- Large downloads: consider streaming directly to client instead of creating ZIPs if disk space is constrained.
- Production hardening:
  - Use a reverse proxy to terminate TLS and handle domain, rate-limiting, and access control.
  - Replace the simple password scheme with signed URLs (HMAC) or short-lived tokens.
  - Add request logging and access controls to prevent abuse.

## Next steps

Would you like a short `docs/SETUP.md` snippet explaining how to expose this helper under HTTPS via nginx (example config), or should I document `src/services/downloadService.ts` next?
