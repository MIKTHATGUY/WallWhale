import fs from "node:fs";
import path from "node:path";
import chalk from "chalk";
import createSpinner from "ora";
import inquirer from "inquirer";
import selfsigned from "selfsigned";
import acme from "acme-client";
import { env } from "./env.js";

/**
 * Certificate Management Utility
 * Handles self-signed, mkcert, and Let's Encrypt certificate generation with auto-elevation
 */

export interface CertificateInfo {
  certPath: string;
  keyPath: string;
  type: "self-signed" | "lets-encrypt" | "existing";
  expiresAt?: Date;
  domains?: string[];
}

export class CertificateManager {
  private certsDir: string;

  constructor(certsDir = "certs") {
    this.certsDir = certsDir;
    this.ensureCertsDirectory();
  }

  /**
   * Ensure certificates directory exists
   */
  private ensureCertsDirectory(): void {
    if (!fs.existsSync(this.certsDir)) {
      fs.mkdirSync(this.certsDir, { recursive: true });
    }
  }

  /**
   * Check if certificates exist and are valid
   */
  public checkCertificates(): CertificateInfo | null {
    const certPath = path.join(this.certsDir, "cert.pem");
    const keyPath = path.join(this.certsDir, "key.pem");

    if (!fs.existsSync(certPath) || !fs.existsSync(keyPath)) {
      return null;
    }

    try {
      const certContent = fs.readFileSync(certPath, "utf8");
      const cert = this.parseCertificate(certContent);

      return {
        certPath,
        keyPath,
        type: this.detectCertificateType(certContent),
        expiresAt: cert.expiresAt,
        domains: cert.domains,
      };
    } catch (error) {
      console.warn(chalk.yellow("‚ö†Ô∏è  Existing certificates appear to be invalid"));
      return null;
    }
  }

  /**
   * Parse certificate information
   */
  private parseCertificate(certContent: string) {
    const lines = certContent.split("\n");
    const issuedBy = lines.find((line) => line.includes("Issuer:")) || "";

    return {
      expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
      domains: ["localhost", "127.0.0.1"],
      isLetsEncrypt: issuedBy.includes("Let's Encrypt"),
    };
  }

  /**
   * Detect certificate type
   */
  private detectCertificateType(certContent: string): "self-signed" | "lets-encrypt" | "existing" {
    if (certContent.includes("Let's Encrypt")) {
      return "lets-encrypt";
    }
    if (certContent.includes("Generated by DepotDownloader")) {
      return "self-signed";
    }
    return "existing";
  }

  /**
   * Check if running as administrator on Windows
   */
  private async isRunningAsAdmin(): Promise<boolean> {
    const os = await import("os");
    if (os.platform() !== "win32") {
      return true;
    }

    try {
      const { execSync } = await import("child_process");
      // Check elevation using WindowsPrincipal (accurate under UAC)
      const ps =
        "if ((New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) { exit 0 } else { exit 1 }";
      execSync(
        `powershell -NoProfile -ExecutionPolicy Bypass -Command "${ps.replace(/\"/g, '\\\"')}"`,
        {
          stdio: "ignore",
        }
      );
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Generate certificate using mkcert (with auto-install and auto-elevation)
   */
  public async generateMkcertCertificate(
    domains: string[] = ["localhost", "127.0.0.1"]
  ): Promise<CertificateInfo> {
    const spinner = createSpinner("üîß Checking for mkcert...").start();

    try {
      const { execSync } = await import("child_process");

      try {
        execSync("mkcert -version", { stdio: "pipe" });
        spinner.text = "‚úÖ mkcert found, generating certificate...";
      } catch {
        spinner.warn(chalk.yellow("‚ö†Ô∏è  mkcert not found"));

        console.log(
          chalk.yellow("\nüí° mkcert provides browser-trusted certificates for development")
        );
        console.log(chalk.gray("   No more browser security warnings for localhost!\n"));

        const { action } = await inquirer.prompt([
          {
            type: "list",
            name: "action",
            message: "What would you like to do?",
            choices: [
              {
                name: "üöÄ Auto-install mkcert (Recommended - auto-elevates if needed)",
                value: "install",
                short: "Auto-install",
              },
              {
                name: "üîß Use self-signed certificate instead",
                value: "fallback",
                short: "Self-signed fallback",
              },
              {
                name: "üìñ Show manual installation instructions",
                value: "manual",
                short: "Manual install",
              },
              {
                name: "‚ùå Cancel certificate generation",
                value: "cancel",
                short: "Cancel",
              },
            ],
          },
        ]);

        switch (action) {
          case "install":
            return this.autoInstallMkcert(domains);

          case "fallback":
            console.log(chalk.blue("üîÑ Falling back to self-signed certificate..."));
            return this.generateSelfSignedCertificate({
              commonName: domains[0] || "localhost",
              organization: "DepotDownloader Development",
              country: "US",
              days: 365,
            });

          case "manual":
            this.showMkcertInstallInstructions();
            throw new Error("Please install mkcert manually and run the command again");

          case "cancel":
            throw new Error("Certificate generation cancelled by user");

          default:
            throw new Error("Invalid option selected");
        }
      }

      spinner.text = "Installing local CA...";
      try {
        execSync("mkcert -install", { stdio: "pipe" });
      } catch {
        // CA might already be installed
      }

      spinner.text = "Generating certificates...";
      const certPath = path.join(this.certsDir, "cert.pem");
      const keyPath = path.join(this.certsDir, "key.pem");

      execSync(`mkcert -cert-file "${certPath}" -key-file "${keyPath}" ${domains.join(" ")}`, {
        stdio: "pipe",
        cwd: process.cwd(),
      });

      spinner.succeed(chalk.green("‚úÖ mkcert certificate generated successfully"));

      // Auto-update .env file
      this.updateEnvFile({
        TLS_ENABLE: "true",
        TLS_CERT_PATH: certPath,
        TLS_KEY_PATH: keyPath,
      });

      return {
        certPath,
        keyPath,
        type: "self-signed",
        expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
        domains,
      };
    } catch (error) {
      spinner.fail(chalk.red("‚ùå Failed to generate certificate"));
      throw error;
    }
  }

  /**
   * Auto-install mkcert with automatic elevation
   */
  private async autoInstallMkcert(domains: string[]): Promise<CertificateInfo> {
    const { execSync } = await import("child_process");
    const os = await import("os");

    console.log(chalk.cyan("\nüöÄ Auto-installing mkcert..."));

    const platform = os.platform();
    let installCommand = "";
    let packageManager = "";

    try {
      if (platform === "win32") {
        try {
          execSync("choco --version", { stdio: "pipe" });
          installCommand = "choco install mkcert -y";
          packageManager = "Chocolatey";
        } catch {
          try {
            execSync("scoop --version", { stdio: "pipe" });
            installCommand = "scoop install mkcert";
            packageManager = "Scoop";
          } catch {
            return this.downloadMkcertManually(domains);
          }
        }
      } else if (platform === "darwin") {
        try {
          execSync("brew --version", { stdio: "pipe" });
          installCommand = "brew install mkcert";
          packageManager = "Homebrew";
        } catch {
          throw new Error("Homebrew not found. Please install Homebrew first: https://brew.sh");
        }
      } else {
        try {
          execSync("apt --version", { stdio: "pipe" });
          installCommand = "sudo apt install mkcert";
          packageManager = "APT";
        } catch {
          try {
            execSync("yum --version", { stdio: "pipe" });
            installCommand = "sudo yum install mkcert";
            packageManager = "YUM";
          } catch {
            throw new Error("No supported package manager found. Please install mkcert manually.");
          }
        }
      }

      console.log(chalk.blue(`üì¶ Installing mkcert using ${packageManager}...`));
      if (platform === "win32" && packageManager === "Chocolatey") {
        console.log(chalk.cyan("üîë Administrator privileges will be automatically requested"));
      }

      const { proceed } = await inquirer.prompt([
        {
          type: "confirm",
          name: "proceed",
          message: `Install mkcert using ${packageManager}? ${platform === "win32" && packageManager === "Chocolatey" ? "(Will auto-elevate)" : ""}`,
          default: true,
        },
      ]);

      if (!proceed) {
        console.log(chalk.yellow("‚ö†Ô∏è  Installation cancelled. Using self-signed certificate..."));
        return this.generateSelfSignedCertificate({
          commonName: domains[0] || "localhost",
          organization: "WallWhale (Self-Signed Fallback)",
          days: 365,
        });
      }

      const spinner = createSpinner("Installing mkcert...").start();
      spinner.color = "yellow";
      spinner.stop();

      try {
        if (platform === "win32" && packageManager === "Chocolatey") {
          // Auto-elevate for Chocolatey
          const isAdmin = await this.isRunningAsAdmin();

          if (!isAdmin) {
            spinner.info("üîë Auto-elevating to administrator...");
            console.log(chalk.yellow("üí° Chocolatey requires administrator privileges"));
            console.log(chalk.cyan("   A new elevated PowerShell window will open"));
            console.log(chalk.gray("   Approve UAC and watch the installation output"));

            const { spawn } = await import("child_process");

            // Create a PowerShell script to run Chocolatey visibly
            const psScript = `
Write-Host ''
Write-Host '==============================================='
Write-Host ' Chocolatey mkcert Installation (Elevated)'
Write-Host '==============================================='
Write-Host ''
Write-Host 'Starting installation...'
try {
  choco install mkcert -y
  $code = $LASTEXITCODE
} catch {
  $code = 1
}
Write-Host ''
Write-Host ('Installation completed with exit code: ' + $code)
if ($code -eq 0) {
  Write-Host 'SUCCESS: mkcert installed successfully!'
} else {
  Write-Host ('ERROR: Installation failed with code ' + $code)
}
Write-Host ''
Write-Host 'Press Enter to close this window...'
[void][System.Console]::ReadLine()
exit $code
`;

            const tempPs1 = path.join(process.cwd(), "temp_mkcert_install.ps1");
            fs.writeFileSync(tempPs1, psScript, { encoding: "utf8" });

            // Launch visible elevated PowerShell
            const startCommand = `Start-Process -FilePath PowerShell -ArgumentList '-NoProfile','-ExecutionPolicy','Bypass','-File','${tempPs1.replace(/\\/g, "/")}' -Verb RunAs -WindowStyle Normal -Wait`;
            const elevated = spawn(
              "powershell",
              ["-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", startCommand],
              {
                stdio: ["ignore", "ignore", "ignore"],
                shell: true,
              }
            );

            await new Promise((resolve, reject) => {
              const timeoutId = setTimeout(() => {
                try {
                  elevated.kill();
                } catch {}
                reject(new Error("Installation timed out"));
              }, 300000);

              elevated.on("close", (code) => {
                clearTimeout(timeoutId);
                try {
                  fs.unlinkSync(tempPs1);
                } catch {}
                resolve(code);
              });

              elevated.on("error", (err) => {
                clearTimeout(timeoutId);
                try {
                  fs.unlinkSync(tempPs1);
                } catch {}
                reject(err);
              });
            });
          } else {
            // Already admin
            execSync(installCommand, { stdio: "pipe" });
          }
        } else {
          // Other platforms
          const { exec } = await import("child_process");
          const { promisify } = await import("util");
          const execAsync = promisify(exec);

          await execAsync(installCommand, {
            timeout: 120000,
            maxBuffer: 1024 * 1024,
          });
        }

        spinner.succeed("‚úÖ mkcert installed successfully!");

        // Verify installation
        try {
          execSync("mkcert -version", { stdio: "pipe" });
        } catch {
          throw new Error("mkcert installation completed but command not found in PATH");
        }

        console.log(chalk.green("üîÑ Proceeding with certificate generation..."));
        return this.generateMkcertCertificate(domains);
      } catch (error) {
        spinner.fail("‚ùå Failed to install mkcert");
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.log(chalk.red(`Error: ${errorMessage}`));

        const { fallback } = await inquirer.prompt([
          {
            type: "confirm",
            name: "fallback",
            message: "Installation failed. Use self-signed certificate instead?",
            default: true,
          },
        ]);

        if (fallback) {
          return this.generateSelfSignedCertificate({
            commonName: domains[0] || "localhost",
            organization: "WallWhale (Self-Signed Fallback)",
            days: 365,
          });
        } else {
          throw new Error("mkcert installation failed and fallback declined");
        }
      }
    } catch (error) {
      console.log(chalk.red(`‚ùå Auto-installation failed: ${error}`));
      this.showMkcertInstallInstructions();
      throw new Error("Please install mkcert manually and run the command again");
    }
  }

  /**
   * Generate a self-signed certificate using the selfsigned library
   */
  public generateSelfSignedCertificate(options: {
    commonName: string;
    organization?: string;
    country?: string;
    days?: number;
  }): CertificateInfo {
    const cn = options.commonName || "localhost";
    const org = options.organization || "DepotDownloader";
    const country = options.country || "US";
    const days = options.days ?? 365;

    const attrs = [
      { name: "commonName", value: cn },
      { name: "organizationName", value: org },
      { name: "countryName", value: country },
    ];

    const altNames = [] as Array<{ type: 2; value: string } | { type: 7; ip: string }>;
    // Add typical dev alt names
    if (!/^\d+\.\d+/.test(cn)) {
      altNames.push({ type: 2, value: cn });
    }
    altNames.push({ type: 2, value: "localhost" });
    altNames.push({ type: 7, ip: "127.0.0.1" });

    const pems = selfsigned.generate(
      attrs as any,
      {
        days,
        keySize: 2048,
        extensions: [
          {
            name: "basicConstraints",
            cA: true,
          },
          {
            name: "subjectAltName",
            altNames,
          },
        ],
      } as any
    );

    const certPath = path.join(this.certsDir, "cert.pem");
    const keyPath = path.join(this.certsDir, "key.pem");
    fs.writeFileSync(certPath, pems.cert);
    fs.writeFileSync(keyPath, pems.private);
    try {
      fs.chmodSync(keyPath, 0o600);
    } catch {}

    this.updateEnvFile({
      TLS_ENABLE: "true",
      TLS_CERT_PATH: certPath,
      TLS_KEY_PATH: keyPath,
    });

    return {
      certPath,
      keyPath,
      type: "self-signed",
      expiresAt: new Date(Date.now() + days * 24 * 60 * 60 * 1000),
      domains: [cn, "localhost", "127.0.0.1"],
    };
  }

  /**
   * Update .env file with certificate settings
   */
  private updateEnvFile(settings: Record<string, string>): void {
    try {
      const envPath = ".env";
      let envContent = "";

      // Read existing .env if it exists
      if (fs.existsSync(envPath)) {
        envContent = fs.readFileSync(envPath, "utf8");
      }

      // Update or add each setting
      for (const [key, value] of Object.entries(settings)) {
        const regex = new RegExp(`^${key}=.*$`, "m");
        const newLine = `${key}=${value}`;

        if (regex.test(envContent)) {
          envContent = envContent.replace(regex, newLine);
        } else {
          envContent += envContent.endsWith("\n") ? "" : "\n";
          envContent += `${newLine}\n`;
        }
      }

      fs.writeFileSync(envPath, envContent);
      console.log(chalk.green("‚úÖ Environment configuration updated"));
    } catch (error) {
      console.warn(chalk.yellow("‚ö†Ô∏è  Failed to update .env file:", error));
    }
  }

  /**
   * Download mkcert manually for Windows
   */
  private async downloadMkcertManually(domains: string[]): Promise<CertificateInfo> {
    console.log(chalk.yellow("\nüì• No package manager found. Manual download required."));
    console.log(chalk.cyan("   Please follow these steps:"));
    console.log(chalk.white("   1. Go to: https://github.com/FiloSottile/mkcert/releases"));
    console.log(chalk.white("   2. Download mkcert-v1.4.4-windows-amd64.exe"));
    console.log(chalk.white("   3. Rename it to mkcert.exe"));
    console.log(chalk.white("   4. Add it to your PATH or place in system directory"));

    const { downloaded } = await inquirer.prompt([
      {
        type: "confirm",
        name: "downloaded",
        message: "Have you downloaded and installed mkcert manually?",
        default: false,
      },
    ]);

    if (downloaded) {
      try {
        return this.generateMkcertCertificate(domains);
      } catch {
        console.log(chalk.yellow("‚ö†Ô∏è  mkcert still not found. Using self-signed certificate..."));
        return this.generateSelfSignedCertificate({
          commonName: domains[0] || "localhost",
          organization: "WallWhale (Self-Signed Fallback)",
          days: 365,
        });
      }
    } else {
      console.log(chalk.blue("üîÑ Falling back to self-signed certificate..."));
      return this.generateSelfSignedCertificate({
        commonName: domains[0] || "localhost",
        organization: "WallWhale (Self-Signed Fallback)",
        days: 365,
      });
    }
  }

  /**
   * Show manual installation instructions for mkcert
   */
  private showMkcertInstallInstructions(): void {
    console.log(chalk.bold.cyan("\nüìñ Manual mkcert Installation"));
    console.log(chalk.yellow("Choose your platform:\n"));

    console.log(chalk.bold("ü™ü Windows:"));
    console.log(chalk.white("   ‚Ä¢ Chocolatey: choco install mkcert"));
    console.log(chalk.white("   ‚Ä¢ Scoop: scoop install mkcert"));
    console.log(chalk.white("   ‚Ä¢ Manual: https://github.com/FiloSottile/mkcert/releases\n"));

    console.log(chalk.bold("üçé macOS:"));
    console.log(chalk.white("   ‚Ä¢ Homebrew: brew install mkcert\n"));

    console.log(chalk.bold("üêß Linux:"));
    console.log(chalk.white("   ‚Ä¢ Ubuntu/Debian: sudo apt install mkcert"));
    console.log(chalk.white("   ‚Ä¢ Arch: pacman -S mkcert"));
    console.log(chalk.white("   ‚Ä¢ Manual: https://github.com/FiloSottile/mkcert/releases\n"));

    console.log(chalk.cyan("üîó More info: https://github.com/FiloSottile/mkcert\n"));
  }

  /**
   * Interactive certificate setup
   */
  public async interactiveCertificateSetup(): Promise<CertificateInfo> {
    console.log(chalk.bold.cyan("\nüîê Certificate Setup Wizard"));
    console.log(chalk.gray("Configure TLS certificates for your WallWhale\n"));

    console.log(chalk.bold("üìã Certificate Types:"));
    console.log(
      chalk.green("   üîß Self-signed") + chalk.dim(" - Works everywhere, browser warnings")
    );
    console.log(
      chalk.green("   üõ°Ô∏è  mkcert") + chalk.dim(" - Trusted by browsers, auto-installs & elevates")
    );
    console.log(
      chalk.green("   üåê Let's Encrypt") + chalk.dim(" - Production ready, requires public domain")
    );
    console.log(chalk.green("   üìÅ Existing") + chalk.dim(" - Use your own certificate files\n"));

    const { certificateType } = await inquirer.prompt([
      {
        type: "list",
        name: "certificateType",
        message: "Choose certificate type:",
        choices: [
          {
            name: "üîß Self-signed certificate (Recommended for development)",
            value: "self-signed",
            short: "Self-signed",
          },
          {
            name: "üõ°Ô∏è  mkcert certificate (Trusted development - auto-installs & elevates)",
            value: "mkcert",
            short: "mkcert",
          },
          {
            name: "üåê Let's Encrypt certificate (Production - requires public domain)",
            value: "lets-encrypt",
            short: "Let's Encrypt",
          },
          {
            name: "üìÅ Use existing certificates",
            value: "existing",
            short: "Existing",
          },
        ],
      },
    ]);

    switch (certificateType) {
      case "self-signed":
        return this.setupSelfSignedCertificate();

      case "mkcert":
        return this.setupMkcertCertificate();

      case "lets-encrypt":
        return this.setupLetsEncryptCertificate();

      case "existing":
        return this.setupExistingCertificates();

      default:
        throw new Error("Invalid certificate type selected");
    }
  }

  private async setupSelfSignedCertificate(): Promise<CertificateInfo> {
    const answers = await inquirer.prompt([
      {
        type: "input",
        name: "commonName",
        message: "Common Name (CN):",
        default: "localhost",
      },
      {
        type: "input",
        name: "organization",
        message: "Organization:",
        default: "WallWhale",
      },
      {
        type: "number",
        name: "days",
        message: "Validity period (days):",
        default: 365,
      },
    ]);

    return this.generateSelfSignedCertificate(answers);
  }

  private async setupMkcertCertificate(): Promise<CertificateInfo> {
    const answers = await inquirer.prompt([
      {
        type: "input",
        name: "domains",
        message: "Domains (comma-separated):",
        default: "localhost,127.0.0.1",
        filter: (input) => input.split(",").map((d: string) => d.trim()),
      },
    ]);

    return this.generateMkcertCertificate(answers.domains);
  }

  private async setupLetsEncryptCertificate(): Promise<CertificateInfo> {
    console.log(chalk.yellow("\n‚ö†Ô∏è  Let's Encrypt Requirements:"));
    console.log(chalk.dim("   ‚Ä¢ Public domain name (no localhost/127.0.0.1)"));
    console.log(chalk.dim("   ‚Ä¢ Domain must resolve to this server's public IP"));
    console.log(chalk.dim("   ‚Ä¢ HTTP port 80 must be accessible from internet"));
    console.log(chalk.dim("   ‚Ä¢ Server must be publicly reachable\n"));

    const answers = await inquirer.prompt([
      {
        type: "input",
        name: "domain",
        message: "Public domain name:",
        validate: (input) => {
          if (!input || !input.includes(".")) {
            return "Please enter a valid domain name (e.g., myserver.example.com)";
          }
          if (
            input.includes("localhost") ||
            input.includes("127.0.0.1") ||
            input.includes("192.168.")
          ) {
            return "Let's Encrypt doesn't support localhost or private IP addresses";
          }
          return true;
        },
      },
      {
        type: "input",
        name: "email",
        message: "Contact email:",
        validate: (input) => {
          if (!input || !input.includes("@")) {
            return "Please enter a valid email address";
          }
          return true;
        },
      },
      {
        type: "confirm",
        name: "staging",
        message: "Use Let's Encrypt staging environment? (recommended for testing)",
        default: true,
      },
      {
        type: "confirm",
        name: "confirmRequirements",
        message: "I confirm this server is publicly accessible and the domain resolves correctly",
        default: false,
      },
    ]);

    if (!answers.confirmRequirements) {
      throw new Error("Let's Encrypt requires public accessibility confirmation");
    }

    return this.generateLetsEncryptCertificate(answers);
  }

  private async setupExistingCertificates(): Promise<CertificateInfo> {
    const answers = await inquirer.prompt([
      {
        type: "input",
        name: "certPath",
        message: "Certificate file path:",
        default: "certs/cert.pem",
      },
      {
        type: "input",
        name: "keyPath",
        message: "Private key file path:",
        default: "certs/key.pem",
      },
    ]);

    if (!fs.existsSync(answers.certPath) || !fs.existsSync(answers.keyPath)) {
      throw new Error("Certificate or key file not found");
    }

    return {
      certPath: answers.certPath,
      keyPath: answers.keyPath,
      type: "existing",
    };
  }

  public async generateLetsEncryptCertificate(options: {
    domain: string;
    email: string;
    staging?: boolean;
  }): Promise<CertificateInfo> {
    const spinner = createSpinner("üåê Obtaining Let's Encrypt certificate...").start();

    try {
      const directoryUrl = options.staging
        ? acme.directory.letsencrypt.staging
        : acme.directory.letsencrypt.production;

      const client = new acme.Client({
        directoryUrl,
        accountKey: await acme.crypto.createPrivateKey(),
      });

      spinner.text = "Creating ACME account...";
      await client.createAccount({
        termsOfServiceAgreed: true,
        contact: [`mailto:${options.email}`],
      });

      spinner.text = "Creating certificate order...";
      const order = await client.createOrder({
        identifiers: [{ type: "dns", value: options.domain }],
      });

      spinner.text = "Getting authorization challenges...";
      const authorizations = await client.getAuthorizations(order);

      for (const authz of authorizations) {
        const challenge = authz.challenges.find((c: any) => c.type === "http-01");
        if (!challenge) {
          throw new Error("HTTP-01 challenge not available");
        }

        const keyAuthorization = await client.getChallengeKeyAuthorization(challenge);

        spinner.text = `Setting up HTTP challenge for ${authz.identifier.value}...`;

        console.log(chalk.yellow(`\nüîç Manual step required:`));
        console.log(
          chalk.cyan(
            `   Serve this content at: http://${options.domain}/.well-known/acme-challenge/${challenge.token}`
          )
        );
        console.log(chalk.white(`   Content: ${keyAuthorization}`));

        const { proceed } = await inquirer.prompt([
          {
            type: "confirm",
            name: "proceed",
            message: "Have you set up the HTTP challenge? Ready to verify?",
            default: false,
          },
        ]);

        if (!proceed) {
          throw new Error("HTTP challenge setup cancelled");
        }

        spinner.text = "Verifying challenge...";
        await client.verifyChallenge(authz, challenge);
      }

      spinner.text = "Waiting for order to be ready...";
      let orderStatus = await client.getOrder(order);
      while (orderStatus.status === "pending") {
        await new Promise((resolve) => setTimeout(resolve, 1000));
        orderStatus = await client.getOrder(order);
      }

      if (orderStatus.status !== "ready") {
        throw new Error(`Order failed with status: ${orderStatus.status}`);
      }

      spinner.text = "Finalizing certificate order...";
      const [key, csr] = await acme.crypto.createCsr({
        commonName: options.domain,
      });

      await client.finalizeOrder(order, csr);
      const cert = await client.getCertificate(order);

      const certPath = path.join(this.certsDir, "cert.pem");
      const keyPath = path.join(this.certsDir, "key.pem");

      fs.writeFileSync(certPath, cert);
      fs.writeFileSync(keyPath, key);
      fs.chmodSync(keyPath, 0o600);

      spinner.succeed(chalk.green("‚úÖ Let's Encrypt certificate obtained successfully"));

      // Auto-update .env file
      this.updateEnvFile({
        TLS_ENABLE: "true",
        TLS_CERT_PATH: certPath,
        TLS_KEY_PATH: keyPath,
      });

      return {
        certPath,
        keyPath,
        type: "lets-encrypt",
        expiresAt: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),
        domains: [options.domain],
      };
    } catch (error) {
      spinner.fail(chalk.red("‚ùå Failed to obtain Let's Encrypt certificate"));
      throw error;
    }
  }
}

export const certificateManager = new CertificateManager();
